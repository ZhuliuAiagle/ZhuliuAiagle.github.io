---
layout: post
title:  "Primer学习笔记4（8.4）"
date:   2017-08-04 17:44:05 +0700
categories: jekyll update
---
Primer学习笔记4（8.4）

4.1 表达式基础

4.1.1 基本概念

1) 一元运算符，二元运算符，三元运算符，组合运算符，运算对象与类型转换

2) 重载运算符:当运算符作用于类类型的运算对象时，用户可自行定义其含义。因为这种自定义的过程事实上是为已经存在的运算符赋予了另外一层含义，所以称之为重载
运算符；

3) 重载运算符:>>　<< string vector和迭代器使用的运算符都是重载的运算符；

4) 使用重载运算符时，包括运算对象的类型和返回值的类型都是由该运算符定义的，但是运算对象的个数/运算符的优先级和结合律是无法改变的。

5) 左值（are-value）和右值（e-value):C++表达式要不是左值，要不是右值；原本帮助记忆：左值可以位于赋值语句的左侧，右值则不能。

6) C++中归纳：被用作右值时，用的是对象的值（内容），被用作左值时，用的是对象的身份（在内存中的位置）；

7) 重要原则:在需要右值的地方可以用左值代替，但是不能把右值当成左值使用；

8) 几个左值右值的实例：

9) decltype关键字时左值右值也有不同。如 int *p；decltype(*p)的结果是int&，而decltype(&p)的结果是int**.

4.1.2 优先级与结合律

1) 复合表达式；

2) 括号无视优先级与结合律；

3) 同一组内运算符优先级相同；

4.1.3 求值顺序

1) 一种未定义行为：cout<<i<<" "<<++i<<endl; 因为<<运算符没有规定何时以及如何对运算对象求值；

2) 4种明确规定运算对象求值顺序的运算符：（&&（先左后右，左边假就不管右边的语句了，右边语句如有变值效果也会无效），||（同理,这被成为短路求值策略）, 
?: 和 ,（最后一个式子的值是整个逗号表达式的值））

3) 运算对象的求值顺序与优先级和结合律无关。如f()+g()*h()+j()表达式，对于这些函数的调用顺序并没有明确规定。如果四个是无关函数，则调用顺序不受限制，
反之(有相干变量或相干参数调用)，则会产生未定义的错误行为;

4) 处理复合表达式：1.拿不准时最好用括号来确保逻辑正确，2.如果改变了某个运算对象的值，在表达式的其他地方不要在使用这个运算对象，除非当改变运算对象的子
表达式本身就是另外一个子表达式的运算对象时该规则无效。如*++iter,很明显要先++。

4.2 算术运算符

1) 算术运算符的运算对象和 求值结果都是右值；所有运算对象将会被转化为同一类型；

2) 留意溢出和其他算术异常；

3) C++11规定商一律向零取整（即直接忽略小数部分）；

4) C++11规定在取余运算中，如果m%n不等于0，那么它的符号和m相同。

4.3 逻辑和关系运算符

1) 逻辑和关系运算符的返回值都是布尔类型；

2) &&和||的短路求值策略（前文）；

3) TIP：string可能特别大，使用引用进行auto-for遍历可以避免建立拷贝。

4) 进行比较运算时除非比较的对象是bool类型，否则不要使用布尔字面值true和false作为运算对象；(使用0/1或不写)

5) 此处遇到过一个问题，已经写在了之前的博客中；

4.4 赋值运算符

1) 赋值运算符的运算对象必须是一个可以修改的左值；

2) C++11标准允许基于花括号的列表赋值法（不一定是初始化）；

3) 列表赋值/初始化出现信息丢失风险（double赋给int）时会报错,括号初始化和普通赋值就不会。

4) 如果左侧是内置类型，初始值列表最多只能包含一个值；

5) 对于类类型来说，赋值运算的细节由类本身决定，是为重载；

6) 无论左侧运算对象的了行是什么，初始值列表都不能为空；

7) 赋值运算满足右结合律；

8) TIP:一种错误：不能把指针的值赋给int;

9) 优先级较低；

10)复合赋值运算符；

4.5 递增递减运算符

1) 前置版本和后置版本；

2) C++建议：除非必需，否则不用递增递减运算符的后置版本（i++）；有可能会为了储存先前的值降低程序效率。

3) 但可以考虑使用*iter++这种简洁的表达式；

4) 递增和递减会改变运算对象的值，所以要提防在复合表达式中错用这两个运算符；

4.6 成员访问运算符

1) . 和 ->

2) 解引用运算符的优先级低于点运算符;

4.7 条件运算符

1) cond?expr1:expr2,真则expr1，否则expr2；

2) 当条件运算符的两个表达式都是左值或能转换为同一左值类型时，运算的结果是左值，否则运算的结果是右值(?)；

4.7.1 嵌套条件运算符

1) 条件运算符满足右结合律，意味着运算对象(一般)按照从右向左的顺序结合。

2) 例子:finalgrade = (grade > 90) ? "high class" : (grade < 60) ? : "fail" : "pass"; 靠右边的条件运算构成了靠左边的分支；

4.8 位运算符

1) ~按位反 << 左移 >>右移 &按位与 ^按位异或 |按位或

2) 移位运算符满足左结合律.

4.9 sizeof运算符

1) sizeof所得类型是一个size_t类型；

2) sizeof(*p)即使p时无效指针也不影响；

3) sizeof运算不会把数组转化为指针来处理;

4) 对string或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。

4.10 逗号运算符

1)真正的值是最右表达式的值，但前面的语句也会执行！

4.11 类型转换

1)隐式类型转换；发生条件？（见书P141）；

4.11.1 算术转换

1) 整型提升；（char等小整型转换为大整型，前提是转换后的类型能容纳原来的值，注意无符号类型的转换！无符号不小于带符号，带符号转无符号；带符号大于无符号，
转换结果依赖于机器，如果无符号能放到带符号容器中，则无符号转带符号，否则带符号转无符号。详细见书P142）

4.11.2 其他隐式类型转换

1)数组转指针，指针的转换，转为bool，转为常量，类类型定义的转换

4.11.3 显式转换（强制）

1) cast-name<type>(expression)

2) cast-name:static_cast/dyanamic_cast/const_cast/reinterpret_cast（危险）
.END


[jekyll-docs]: http://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/
